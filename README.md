# realtime-rendering

## 图形渲染管线

### 2.2 应用阶段

开发者对于应用阶段有完全的控制权，因为它在CPU上面运行。所以开发者可以完全确定怎么实现，并且通过修改来改进性能。这里的改变也能影响到后续几个阶段。比如应用阶段的算法或者设置可以减少需要渲染的三角形数量。

所有一切说明，有一些应用工作可以被放在GPU上执行，使用一种叫做compute shader的分离模式进行。这种模式把GPU当作一个高并发通用处理器。

在应用阶段的最后，需要被渲染的几何体会被送到几何处理阶段。这些就是rendering primitives渲染图元，也就是点、线、三角形。这就是应用阶段最重要的事情。

基于软件实现此阶段的结果就是它不能被分解成更小的子阶段substages（当然CPU自己可以被划分成流水线阶段，但和这里没有关联），不像几何处理、光栅化和像素处理阶段。但是，为了加强性能，这一阶段通常会在多核中并行被执行。在CPU设计中这被称为superscalar construction超标量构建，因为它能在一个阶段同时进行多次处理。18.5节展示了使用多处理核心的多种方法。

一个通常被用在此阶段的处理是碰撞检测collision detection。应用阶段也是读取其它输入源的地方，比如键盘、鼠标或者头戴式显示。加速算法，比如特殊的提出算法（19章）也是在这里实现的，需要用到其它管线不能处理的东西。

### 2.3 几何处理

GPU的几何处理阶段对遍历三角形per-triangle和遍历顶点per-vertex操作负责。这个阶段被进一步划分成几个功能阶段：vertex shading，projection，clipping，screen mapping

#### 2.3.1 顶点着色

在顶点着色阶段有两个主要的任务，计算顶点位置以及计算程序猿希望得到顶点什么样的输出，比如法线和纹理坐标。传统的做法是对每个顶点用光源遍历，然后把最终结果颜色存在顶点处。然后这些颜色就在三角形中进行插值。因为这个原因，可编程顶点处理单元也被称作顶点着色器。随着现代GPU的到来，顶点着色阶段变得更痛用了，并不完全是再去evaluate着色方程了，基于程序员的意愿。顶点着色器现在是一个更通用的单元，致力于设置与每个顶点相关联的数据。比如，丁带你着色器可以用第4.4和4.5的方法来制作物体动画。

我们开始描述顶点坐标是怎么被计算时，一系列坐标系就是必要的。

（略）

#### 2.3.2 可选的顶点处理

每个管线都有之前描述的顶点处理。当处理完成后，有一些可选的阶段可以在GPU上执行，顺序是：tessellation、geometry shading、stream output。它们的使用取决于硬件性能--不是所有GPU都有它们，以及程序员的意愿。它们互相独立，并且通常情况下它们不会被使用。更多情况会在第3章被说明。

第一个可选阶段是tessellation。想象你有一个弹力球物体。如果你用一系列三角形来表示则会遇到质量和效果问题。有了tessellation就能用恰当的三角形来细分曲面

我们谈论到了三角形，但是当前时刻的管线我们仅在处理顶点。这些顶点可以被用来描述点、直线、三角形或者其它物体。顶点可以被用来描述曲面，比如一个球。这种表面可以被一系列patches描述，每个patch都由一组顶点构成。tessellation它自己就由一系列阶段组成--hull shader、tessellator、domain shader--这把patch顶点组转成更大顶点组，然后被用来构成新的三角形组。场景相机可以被用来确定多少三角形被生成：越远越少。

接下来的阶段就是geometry shader。geometry shader早于tessellation shader出现，所以更普及。和tessellation shader相似，它获取多种图元，然后产生新的顶点。geometry shader有各种用途，最有名的一种是用于粒子生成。比如烟花，每个火焰球可以用点表示，一个顶点。geometry shader可以把点转换成矩形（两个三角形），朝向观察者并且覆盖多个像素，所以提供了更可信的图元给我们渲染。

最后一个可选阶段是stream output。这个阶段让我们可以使用GPU作为几何引擎。在这个节点我们可以把选择性地把处理后的顶点输出到数组进行更进一步地处理，而不是传到剩下的光线渲染到屏幕上。这些数据可以被CPU使用，也可以被GPU自己使用，在之后的pass中。这个阶段典型地被用于粒子模拟中，比如我们的烟火例子。

这三个阶段按照下面顺序被执行--tessellation、geometry shading、stream output--每个都是可选的。不管它们中哪个被用到，如果我们继续执行管线我们会有一组共坐标系的顶点会被检查是否可见。

#### 2.3.3 剪切

只有当图元整个或者部分在可见体积重才会被传到光栅化阶段。完全在view volume的图元会被保留，完全不在的不会被保留，只有部分在的会被clip。比如一条线一个点在内部一个点在外部，外部的点会被交线点点替代。使用投影矩阵意味着转变后的图元会被单位立方体剪切。在剪切前做view转换以及投影点好处是可以让剪切问题变得一致性。图元总是被单位立方体剪切。

### 2.3.4 屏幕映射

只有被剪切的图元会被传到屏幕映射阶段，坐标系依然是三维的

